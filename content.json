{"meta":{"title":"Cholesterol","subtitle":"你的经历终成谈吐","description":"你的经历终成谈吐","author":"胆固醇","url":"http://unknownfor.github.io","root":"/"},"pages":[{"title":"欢迎来到这里。","date":"2017-03-23T06:24:06.000Z","updated":"2019-12-12T09:37:27.890Z","comments":true,"path":"about/index.html","permalink":"http://unknownfor.github.io/about/index.html","excerpt":"","text":"# 关于博客博客建立于 1490198400(UNIX)，由 Hexo 强力驱动。 # 关于我重度可乐爱好者，所以自命名cholesterol。 加班🐶一只，软件工程专业，喜欢侦探小说和数学。 有两只猫 (´ཀ`」 ∠) 目前的职位是「前端 开发工程师」。 # 联系我如果你希望同我交流，可以发送邮件 （cholesterol54@gmail.com）给我。 偶尔会在 github 上冒泡，fork最近的新的前端代码。"},{"title":"categories","date":"2016-03-23T06:24:06.000Z","updated":"2019-05-23T06:28:42.000Z","comments":true,"path":"categories/index.html","permalink":"http://unknownfor.github.io/categories/index.html","excerpt":"","text":""},{"title":"archive","date":"2016-03-23T06:24:06.000Z","updated":"2019-05-23T07:23:38.000Z","comments":true,"path":"archives/index.html","permalink":"http://unknownfor.github.io/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"H5开发配置","slug":"H5开发配置","date":"2020-03-11T08:46:44.000Z","updated":"2021-08-11T09:10:12.089Z","comments":true,"path":"2020/03/11/H5开发配置/","link":"","permalink":"http://unknownfor.github.io/2020/03/11/H5开发配置/","excerpt":"","text":"whistle全局安装 whistle , 文档地址 使用时用 git 命令行 w2 start，关闭使用w2 stop rules 目录配置 ip 地址为项目运行后npm run dev后的 ip 结果 value 目录下配置1234567vsconsole&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vConsole/3.3.4/vconsole.min.js\"&gt;&lt;/script&gt;run vsconsolevar vConsole = new VConsole(); 配置证书1注意：证书必须安装在企业信任的目录下，不然配置不会成功 whistle script安装 script 插件，下载地址 12npm install -g whistlenpm install -g whistle.script Proxy SwitchyOmega谷歌浏览器安装插件，使用的时候选择【proxy】情景模式 服务器配置","categories":[],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://unknownfor.github.io/tags/移动开发/"}]},{"title":"2019年终总结","slug":"2019年终总结","date":"2020-01-14T07:15:25.000Z","updated":"2021-08-11T11:16:27.620Z","comments":true,"path":"2020/01/14/2019年终总结/","link":"","permalink":"http://unknownfor.github.io/2020/01/14/2019年终总结/","excerpt":"","text":"a、2019年做了哪些工作，列举出最重要的三项并阐述每一项工作取得的效果； b、这三项工作当中有哪些做得好的，哪些做得不好的，要有详尽的分析； c、2020年自己的能力提升计划和关键动作是什么。 单店分析模型 样式、地图 户口簿 单一模块拆分组件 老平台支出预算模块优化 功能更加细化 2019年的工作，主要做了支出预算管理优化、个人额度、万村批量付款、经营指标管理ce&amp;noi济南试点。从不懂为什么要做这样的需求，到逐渐理解。印象最深刻的就是【户口簿】【老平台支出预算模块优化】【单店分析模型】。 资产户口簿列表多，编辑逻辑复杂，因为是在新平台上开发，有严格的eslint规范，所以需要做到细分功能模块，做组件拆分和复用。详情涉及到36个Number类型字段，且都可以修改。不仅区分出手填和一般编辑，还细分出调值和调账功能。对用户角色做了可操作权限的严格区分。详情页的拆成一个table，只负责做展示功能，可编辑功能拆分表格，渲染不同的弹窗模式。 先判断当前用户权限，再去调用操作逻辑代码。 组件还有优化空间， 老平台支出预算模块优化。今年一年总是在【修修补补】这部分模块的功能。一点点的删除和替换旧语法和逻辑代码，换成es6的简介写法。尝试把多处重复使用的css文件改为less写法并压缩。把ajax请求改成手动异步模式。 但是目前为止还是下手紧张，进度缓慢。代码文件还是过大，部分js文件超过了100kb。 单店分析模型 也遇到了和户口簿一样的问题，表单多，需要拆分多个。比较特殊的是没有办法做到代码复用，每一个表单都是独一无二的。样式特殊，需要手动绘制页面，还涉及到饼图和柱状图。 最大的问题就是地图样式问题，因为时间紧迫使用了v-chart，缺少官方文档。没有研究出来如何自定义样式地图，是坤哥帮忙查看源码解决了这个问题，感谢坤哥。 2020年自己的能力提升计划 需要从用户的角度思考功能点交互细节 持续思考提升工程质量的方式，如 TypeScript、Code Review 和自动化测试等 继续研究自动化测试相关。 对门店线一组对期望和想法。 迭代时间最长不要超过三周。更加严谨的执行测试用例。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://unknownfor.github.io/tags/生活/"}]},{"title":"人脸识别门禁功能","slug":"人脸识别门禁功能","date":"2019-07-18T07:53:28.000Z","updated":"2021-08-11T11:47:22.418Z","comments":true,"path":"2019/07/18/人脸识别门禁功能/","link":"","permalink":"http://unknownfor.github.io/2019/07/18/人脸识别门禁功能/","excerpt":"","text":"图片上传微信方法 wx.chooseImage查看预览 返回的wx.preview 遇到了微信公众号开发者工具，调用这两个方法都是报错的问题。发布测试后就发现ok了，原来工具不支持这个方法，还是得真机调试。 封装好的请求和方法一定要调试好了之后再调试，不然不停发布测试实在是耽误时间和精力。 提前测试好文件上传，替换好。抓包测试。12345678910[&#123;id: '', number: '',bank_num:''&#125;,&#123; id: '', number: '',bank_num:''&#125;] 提交报错后， 提交中loading态没有取消 json.data[n].number_encryption = json.data[n].number json.data[n].bene_bank_num_encryption = json.data[n].bene_bank_num json.data[n].number = encryption_arr[n].number json.data[n].bene_bank_num = encryption_arr[n].bene_bank_num //encryption json.data[n].number_encryption = ‘‘ + json.data[n].number_encryption + ‘‘ json.data[n].bene_bank_num_encryption = ‘‘ + json.data[n].bene_bank_num_encryption + ‘‘","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://unknownfor.github.io/tags/移动端/"}]},{"title":"ElementUI和第三方图标库Iconfont","slug":"ElementUI和第三方图标库Iconfont","date":"2019-05-27T07:39:38.000Z","updated":"2020-05-27T07:43:13.872Z","comments":true,"path":"2019/05/27/ElementUI和第三方图标库Iconfont/","link":"","permalink":"http://unknownfor.github.io/2019/05/27/ElementUI和第三方图标库Iconfont/","excerpt":"","text":"遇到一个需求，ElementUI没有符合的图标，需要插入ui提供的图标，所以使用iconfont。 在项目李找到该图标，本次使用的是【xitong】这个图标。选择font class，再选择在线链接，复制这个链接。在less文件里引入这个iconfont，插入到el-input即可使用。 1234567891011121314151617&lt;template&gt; &lt;el-input size=\"medium\" suffix-icon=\"iconfont icon-JYT-icon-xitong\" v-model=\"item.value\" &gt;&lt;/el-input&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; item: &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;@import url('//at.alicdn.com/t/font_1712723_tp9lsy2fuua.css');&lt;/style&gt;","categories":[],"tags":[{"name":"Element","slug":"Element","permalink":"http://unknownfor.github.io/tags/Element/"}]},{"title":"ElementUI table 编辑拓展","slug":"ElementUI-table-编辑拓展","date":"2019-02-27T06:17:21.000Z","updated":"2020-05-27T07:43:09.528Z","comments":true,"path":"2019/02/27/ElementUI-table-编辑拓展/","link":"","permalink":"http://unknownfor.github.io/2019/02/27/ElementUI-table-编辑拓展/","excerpt":"","text":"被调到新的项目组，开始财务模块开发，涉及到大量报表和数字。最近的需求涉及到element table，各种详细的要求，要求拓展目前现有的table内容，期间也遇到了很多问题，现在记录下来。 目录 允许点击table任意一栏编辑 表头合并和样式自定义 允许上传附件 树状table，允许展开折叠操作 根据选择器选择的内容动态新增可编辑的字段 界面编辑操作，输入数据，光标丢失，感觉很卡 表格编辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;style&gt; .el-table-add-row &#123; margin-top: 10px; width: 100%; height: 34px; border: 1px dashed #c1c1cd; border-radius: 3px; cursor: pointer; justify-content: center; display: flex; line-height: 34px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;el-row&gt; &lt;el-col span=\"24\"&gt; &lt;el-table size=\"mini\" :data=\"master_user.data\" border style=\"width: 100%\" highlight-current-row&gt; &lt;el-table-column type=\"index\"&gt;&lt;/el-table-column&gt; &lt;el-table-column v-for=\"(v,i) in master_user.columns\" :prop=\"v.field\" :label=\"v.title\" :width=\"v.width\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;span v-if=\"scope.row.isSet\"&gt; &lt;el-input size=\"mini\" placeholder=\"请输入内容\" v-model=\"master_user.sel[v.field]\"&gt; &lt;/el-input&gt; &lt;/span&gt; &lt;span v-else&gt;&#123;&#123;scope.row[v.field]&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"操作\" width=\"100\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;span class=\"el-tag el-tag--info el-tag--mini\" style=\"cursor: pointer;\" @click=\"pwdChange(scope.row,scope.$index,true)\"&gt; &#123;&#123;scope.row.isSet?'保存':\"修改\"&#125;&#125; &lt;/span&gt; &lt;span v-if=\"!scope.row.isSet\" class=\"el-tag el-tag--danger el-tag--mini\" style=\"cursor: pointer;\"&gt; 删除 &lt;/span&gt; &lt;span v-else class=\"el-tag el-tag--mini\" style=\"cursor: pointer;\" @click=\"pwdChange(scope.row,scope.$index,false)\"&gt; 取消 &lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-col&gt; &lt;el-col span=\"24\"&gt; &lt;div class=\"el-table-add-row\" style=\"width: 99.2%;\" @click=\"addMasterUser()\"&gt;&lt;span&gt;+ 添加&lt;/span&gt;&lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;!-- import Vue before Element --&gt; &lt;script src=\"https://unpkg.com/vue@2.5.17/dist/vue.min.js\"&gt;&lt;/script&gt; &lt;!-- import JavaScript --&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; &lt;script&gt; //id生成工具 这个不用看 示例而已 模拟后台返回的id var generateId = &#123; _count: 1, get()&#123;return ((+new Date()) + \"_\" + (this._count++))&#125; &#125;; //主要内容 var app = new Vue(&#123; el: \"#app\", data: &#123; master_user: &#123; sel: null,//选中行 columns: [ &#123; field: \"type\", title: \"远程类型\", width: 120 &#125;, &#123; field: \"addport\", title: \"连接地址\", width: 150 &#125;, &#123; field: \"user\", title: \"登录用户\", width: 120 &#125;, &#123; field: \"pwd\", title: \"登录密码\", width: 220 &#125;, &#123; field: \"info\", title: \"其他信息\" &#125; ], data: [], &#125;, &#125;, methods: &#123; //读取表格数据 readMasterUser() &#123; //根据实际情况，自己改下啊 app.master_user.data.map(i =&gt; &#123; i.id = generateId.get();//模拟后台插入成功后有了id i.isSet=false;//给后台返回数据添加`isSet`标识 return i; &#125;); &#125;, //添加账号 addMasterUser() &#123; for (let i of app.master_user.data) &#123; if (i.isSet) return app.$message.warning(\"请先保存当前编辑项\"); &#125; let j = &#123; id: 0, \"type\": \"\", \"addport\": \"\", \"user\": \"\", \"pwd\": \"\", \"info\": \"\", \"isSet\": true, \"_temporary\": true &#125;; app.master_user.data.push(j); app.master_user.sel = JSON.parse(JSON.stringify(j)); &#125;, //修改 pwdChange(row, index, cg) &#123; //点击修改 判断是否已经保存所有操作 for (let i of app.master_user.data) &#123; if (i.isSet &amp;&amp; i.id != row.id) &#123; app.$message.warning(\"请先保存当前编辑项\"); return false; &#125; &#125; //是否是取消操作 if (!cg) &#123; if (!app.master_user.sel.id) app.master_user.data.splice(index, 1); return row.isSet = !row.isSet; &#125; //提交数据 if (row.isSet) &#123; //项目是模拟请求操作 自己修改下 (function () &#123; let data = JSON.parse(JSON.stringify(app.master_user.sel)); for (let k in data) row[k] = data[k]; app.$message(&#123; type: 'success', message: \"保存成功!\" &#125;); //然后这边重新读取表格数据 app.readMasterUser(); row.isSet = false; &#125;)(); &#125; else &#123; app.master_user.sel = JSON.parse(JSON.stringify(row)); row.isSet = true; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 表头合并、自定样式、表格附件上传 表头合并参考了element官方文档，只需要在 el-table-column 里面嵌套 el-table-column，就可以实现多级表头；render-header 列标题 Label 区域渲染使用的 Function，就可以实现表头样式自定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;el-table-column label=\"关停期间损失\"&gt; &lt;el-table-column prop=\"landlord_liquidated_damages\" :render-header=\"renderHeader\" label=\"赔付给房东的违约金（元）\" &gt; &lt;template slot-scope=\"scope\"&gt; &#123;&#123; format(scope.row.landlord_liquidated_damages) &#125;&#125;&lt;/template &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"tenant_liquidated_damages\" :render-header=\"renderHeader\" label=\"赔付给租客的违约金（元）\" &gt; &lt;template slot-scope=\"scope\"&gt;&#123;&#123; format(scope.row.tenant_liquidated_damages) &#125;&#125;&lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"client_liquidated_damages\" :render-header=\"renderHeader\" label=\"赔付给委托方的违约金（元）\" &gt; &lt;template slot-scope=\"scope\"&gt;&#123;&#123; format(scope.row.client_liquidated_damages) &#125;&#125;&lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"operating_loss\" :render-header=\"renderHeader\" label=\"经营亏损（元）\" &gt; &lt;template slot-scope=\"scope\"&gt;&#123;&#123; format(scope.row.operating_loss) &#125;&#125;&lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"additional_investment\" :render-header=\"renderHeader\" label=\"追加投资（元）\" &gt; &lt;template slot-scope=\"scope\"&gt;&#123;&#123; format(scope.row.additional_investment) &#125;&#125;&lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table-column&gt;&lt;el-table-column prop=\"upload\" label=\"附件\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;div class=\"files-box\" v-for=\"(a, aIndex) in scope.row.upload\" :key=\"aIndex\" &gt; &lt;div class=\"files-box__name\" :title=\"a.name\"&gt;&#123;&#123; a.name &#125;&#125;&lt;/div&gt; &lt;div class=\"files-box__btn\"&gt; &lt;el-button type=\"text\" @click=\"checkFile(a.url)\"&gt;查看&lt;/el-button&gt; &lt;el-button v-if=\"!isDetail\" type=\"text\" @click=\"delFile(aIndex, scope.$index)\" &gt;删除&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt;&lt;/el-table-column&gt; 12345678910111213141516171819202122232425262728293031323334353637383940/** * 表头样式自定义 */ renderHeader(h, &#123; column, $index &#125;) &#123; let str = '' if ( column.label == '预计总投（万元)' || column.label == '预计NOI/GOP投资回报率（%）' ) &#123; str = '投资收益' &#125; else &#123; str = '关停信息' &#125; return ( &lt;span&gt; &#123;str&#125; &lt;br /&gt; &lt;span class=\"c6\"&gt;&#123;column.label&#125;&lt;/span&gt; &lt;/span&gt; ) &#125;, /** * 删除附件 * @param &#123;*&#125; i 附件index * @param &#123;*&#125; l list的index */ delFile(i, l) &#123; this.list[l].upload.splice(i, 1) &#125;, // 查看加密附件 async checkFile(url) &#123; try &#123; let res = await PmService.getSignedUrl(url) window.open(res.data.url, res.data.url) &#125; catch (e) &#123; console.error(e) &#125; return '#' &#125; 1234567891011121314151617181920212223242526&lt;style&gt;.c6 &#123; color: #606266;&#125;.c6::before &#123; content: \"*\"; color: #f56c6c; margin-right: 4px;&#125;.files-box &#123; position: relative;&#125;.files-box__name &#123; height: 40px; line-height: 40px; width: 110px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.files-box__btn &#123; position: absolute; top: 0; right: 0;&#125;&lt;/style&gt; 树状table，允许展开折叠操作 default-expand-all 是否默认展开所有行，当 Table 包含展开行存在或者为树形表格时有效 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346&lt;template&gt; &lt;div class=\"f-mt\"&gt; &lt;el-table :data=\"data\" style=\"width: 100%;\" row-key=\"id\" :indent=\"6\" :default-expand-all=\"default_expand_all\" border :tree-props=\"&#123; children: 'children', hasChildren: 'hasChildren' &#125;\" &gt; &lt;el-table-column prop=\"name\" label=\"指标名称\"&gt; &lt;template slot-scope=\"scope\"&gt; &#123;&#123; scope.row.name &#125;&#125; &lt;f-tips v-if=\"scope.row.method\" top=\"25%\" :width=\"400\"&gt;&#123;&#123; scope.row.method &#125;&#125;&lt;/f-tips&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"systemValue\" label=\"前台系统取值（元）\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;!-- show_system_desc --&gt; &lt;el-tooltip effect=\"dark\" :content=\"scope.row.show_system_desc\" placement=\"top\" &gt; &lt;el-button type=\"text\"&gt;&#123;&#123; format(scope.row.systemValue) &#125;&#125;&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"manualValue\" label=\"手工补录(元)\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-form&gt; &lt;el-form-item :key=\"scope.row.id\" :error=\"valid[scope.row.id + '_' + scope.row.name]\" &gt; &lt;el-tooltip effect=\"dark\" :content=\"scope.row.show_manual_desc\" placement=\"top\" &gt; &lt;el-input size=\"medium\" @input=\" checkInput( scope.row.manualValue, scope.row.id, scope.row.name ) \" v-model=\"scope.row.manualValue\" placeholder=\"请输入\" &gt;&lt;/el-input&gt; &lt;/el-tooltip&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"total\" label=\"合计(元)\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-tooltip effect=\"dark\" :content=\"scope.row.show_system_desc\" placement=\"top\" &gt; &lt;span&gt; &#123;&#123; scope.row.can_edit ? format( ( Number(scope.row.systemValue) + Number(scope.row.manualValue) ).toFixed(2) ) : format(scope.row.total) &#125;&#125; &lt;/span&gt; &lt;/el-tooltip&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"houses\" label=\"楼栋均摊(元)\" width=\"620\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-form :inline=\"true\" label-position=\"right\" label-width=\"120px\"&gt; &lt;el-form-item v-for=\"(item, index) in scope.row.show_houses\" :label=\"item.name\" :key=\"index\" :error=\"valid[item.id + '_' + scope.row.name]\" &gt; &lt;el-tooltip effect=\"dark\" placement=\"top\" :content=\"item.show_system_desc\" &gt; &lt;el-input size=\"medium\" style=\"width: 130px;\" :disabled=\"!item.can_edit\" @input=\" checkInput(item.value, item.id, scope.row.name, scope.row) \" v-model=\"item.value\" placeholder=\"请输入修改数值\" &gt;&lt;/el-input&gt; &lt;/el-tooltip&gt; &lt;/el-form-item&gt; &lt;el-button class=\"show-btn\" v-if=\"scope.row.houses &amp;&amp; scope.row.houses.length &gt; 2\" type=\"text\" @click=\"handleMore(scope.row)\" &gt;查看更多&lt;/el-button &gt; &lt;/el-form&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;function makeMsg(oriMsg, msg) &#123; return `$&#123;oriMsg&#125;$&#123;msg ? '，' + msg : ''&#125;`&#125;export default &#123; name: 'table-form', props: &#123; data: &#123; type: [Array], required: true &#125;, // 控制树展开折叠 default_expand_all: &#123; type: Boolean, required: true &#125; &#125;, data() &#123; return &#123; valid: &#123;&#125;, title: '', form: &#123; houses: [] &#125;, rules: &#123;&#125;, visible: false, active: ['1'], error_info: [], d_loading: false, list: [], field: &#123; visible: false, loading: false, title: '' &#125; &#125; &#125;, watch: &#123;&#125;, computed: &#123;&#125;, methods: &#123; /** * 编辑 ,校验输入合法 * @param &#123;*&#125; value * @param &#123;*&#125; id * @param &#123;*&#125; name * @param &#123;*&#125; item 当前编辑的item */ checkInput(value, id, name, item) &#123; let i = 14 let f = 2 let all_true = false this.valid[id + '_' + name] = '' let reg = new RegExp(`^-?\\\\d&#123;1,$&#123;i&#125;&#125;(\\\\.\\\\d&#123;1,$&#123;f&#125;&#125;)?$`) if (!reg.test(value)) &#123; this.valid[id + '_' + name] = `最多$&#123;i&#125;位整数$&#123;f&#125;位小数` &#125; // 校验是否还存在其他valid for (let v in this.valid) &#123; if (this.valid[v]) &#123; all_true = false break &#125; else &#123; all_true = true &#125; &#125; let res = 0 if (item.houses &amp;&amp; item.houses.length) &#123; item.houses.forEach((h) =&gt; &#123; res = Utils.floatAdd(res, h.value, 2) &#125;) &#125; item.manualValue = res // 同步更新当前手工补录值 this.$emit('checkInput', all_true) // 通过输入合法性校验 &#125;, // 查看更多楼栋信息 handleMore(data) &#123; this.form = _.clone(data) this.title = data.name this.visible = true &#125;, // 查看明细 goTo(url) &#123; this.$emit('goTo', url) &#125;, /** * 正浮点数限制 * @param &#123;Number&#125; i 整数最大位数 * @param &#123;Number&#125; f 小数最大位数 * @param &#123;Object&#125; options 配置 * isMoreThanZero: 是否强制大于0 * canNegative: 是否允许输入负数 */ float(i, f, options = &#123;&#125;) &#123; return &#123; validator: (rule, value, callback) =&gt; &#123; let reg let msg if (f == 0) &#123; reg = new RegExp(`^-?\\\\d&#123;1,$&#123;i&#125;&#125;$`) &#125; else &#123; reg = new RegExp(`^-?\\\\d&#123;1,$&#123;i&#125;&#125;(\\\\.\\\\d&#123;1,$&#123;f&#125;&#125;)?$`) &#125; if (!value) &#123; callback() &#125; else &#123; if (reg.test(value)) &#123; if ( (options.isMoreThanZero &amp;&amp; Number(value) &lt;= 0) || (!options.canNegative &amp;&amp; Number(value) &lt; 0) ) &#123; msg = '请输入大于零的数值' &#125; else &#123; callback() &#125; &#125; else &#123; msg = `最多$&#123;i&#125;位整数` if (f != 0) &#123; msg += `$&#123;f&#125;位小数` &#125; &#125; &#125; if (msg) &#123; callback(new Error(makeMsg(msg, options.extraMsg))) &#125; &#125;, trigger: 'blur' &#125; &#125;, /* 不允许输入全部是空格 */ notAllBlank(label) &#123; return &#123; validator: (rule, value = '', callback) =&gt; &#123; if (value.trim().length == 0) &#123; callback(new Error(`$&#123;label&#125;不能全部是空格`)) &#125; else &#123; callback() &#125; &#125;, trigger: 'blur' &#125; &#125;, /** * 千分位 * @param &#123;*&#125; str 字符串数字 */ format(str) &#123; if (!str) return str str = str.toString() let minus = false if (/^-/.test(str)) &#123; minus = true str = str.replace(/^-/, '') &#125; let [int, float] = str.split('.') let result = [] for (let i = 0; i &lt; int.length; i++) &#123; result = [int[int.length - i - 1], ...result] if (i % 3 == 2 &amp;&amp; i != int.length - 1) &#123; result = [',', ...result] &#125; &#125; if (float) &#123; return `$&#123;minus ? '-' : ''&#125;$&#123;result.join('')&#125;.$&#123;float&#125;` &#125; return `$&#123;minus ? '-' : ''&#125;$&#123;result.join('')&#125;` &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"less\" scoped&gt;@import '~__assets/var.less';@import url('//at.alicdn.com/t/font_1712723_tp9lsy2fuua.css');.f-fr &#123; float: right;&#125;.f-tooltip &#123; max-width: 700px !important; word-wrap: break-word !important;&#125;.show-btn &#123; position: absolute; right: 20px; top: 13px;&#125;/deep/ .cell &#123; user-select: text;&#125;/deep/ .el-table__row &#123; td &#123; &amp;:last-child &#123; .cell &#123; max-height: 60px; &#125; &#125; &#125;&#125;.dialog-total &#123; height: 32px; text-align: right;&#125;.error-info &#123; color: @c-err; font-size: 16px; line-height: 24px;&#125;.f-i-btn &#123; font-size: 16px;&#125;&lt;/style&gt; 参考链接： Table 表格 elementUi中input输入字符光标在输入一个字符后，光标失去焦点","categories":[],"tags":[{"name":"Element","slug":"Element","permalink":"http://unknownfor.github.io/tags/Element/"}]},{"title":"webview更新地址没有发起请求","slug":"webview更新地址没有发起请求","date":"2018-08-14T13:13:56.000Z","updated":"2020-01-10T08:33:05.698Z","comments":true,"path":"2018/08/14/webview更新地址没有发起请求/","link":"","permalink":"http://unknownfor.github.io/2018/08/14/webview更新地址没有发起请求/","excerpt":"","text":"场景app启动的时候会预加载web页面，web页面依赖app的相关权限数据（例如aoo定位坐标） 首次进入app，用户据胡娥授权定位或者手机定位未开启，这时候web页面已经预加载。(以hash路由为例) 1https://www.baidu.com/index.html#/ 获取不到定位，页面先加载北京的数据。 用户开启手机定位，app获取到经纬度，重新请求一次接口，url地址为 1https://www.baidu.com/index.html#/?lat=143.232232&amp;lon=32.234432 问题url更新并没有请求接口更新数据 解决问题利用watch监听router中query的变化 1234567watch: &#123; '$route' (to, from) &#123; //监听路由是否变化 if(to.query.lat != from.query.lat)&#123; this.loadData();//重新加载数据 &#125; &#125;&#125; APP加载的一直是https://www.baidu.com/index.html#/这个地址，只是后边追加的参数不同，再回想下vue单页面路由的原理，只有访问到对应的路由才会触发对应的页面加载（当前路由和要跳转的路由对应同一个组件时，组件不会被更新，生命周期不会被执行），才会触发页面中的vue的生命周期，所以，可以利用watch来监听路由参数的变化。 参考文章 官方说明","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://unknownfor.github.io/tags/前端/"},{"name":"vue","slug":"vue","permalink":"http://unknownfor.github.io/tags/vue/"},{"name":"移动端","slug":"移动端","permalink":"http://unknownfor.github.io/tags/移动端/"}]},{"title":"学习单元测试 - Jest","slug":"学习单元测试 - Jest","date":"2018-05-04T09:07:56.000Z","updated":"2019-12-12T09:33:15.389Z","comments":true,"path":"2018/05/04/学习单元测试 - Jest/","link":"","permalink":"http://unknownfor.github.io/2018/05/04/学习单元测试 - Jest/","excerpt":"","text":"现在系统功能趋于稳定，想着接入单元测试使用一下。尝试着为公共组件和公共方法编写覆盖全面的单元测试。 Jestvue-cli 自带Jest,开箱即用。在根目录中创建一个名为 jest.config.js 的配置文件。配置文档 1234567891011121314151617181920212223242526module.exports = &#123; // 文件后缀 moduleFileExtensions: ['js', 'jsx', 'json', 'vue'], // 文件如何转换 transform: &#123; '^.+\\\\.vue$': 'vue-jest', '.+\\\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$': 'jest-transform-stub', '^.+\\\\.jsx?$': 'babel-jest' &#125;, // 忽略的文件 transformIgnorePatterns: ['/node_modules/'], // 生成快照需要的插件 snapshotSerializers: ['jest-serializer-vue'], // 需要执行哪些目录下的测试用例 testMatch: [ '**/tests/unit/**/*.spec.(js|jsx|ts|tsx)|**/__tests__/*.(js|jsx|ts|tsx)' ], // 在执行用例前的配置文件 setupFiles: ['./tests/setup.js'], // 测试覆盖率配置 collectCoverage: true, coverageReporters: ['html', 'lcov', 'text-summary'], coverageDirectory: './test/coverage', collectCoverageFrom: ['components/**/*.vue']&#125; 安装1vue add unit-jest 语法断言、异步代码测试、Mock 函数、快照参考文档 异步获取数据肯定是一个常见场景了。异步代码通常会有两种写法，分别为： 回调函数 函数返回 promise 在测试异步代码的时候，通常返回的数据是不确定的，因此我们只需要测试异步代码是否正常返回数据即可。 1234567891011121314// 回调函数的写法，通过 done 来让测试代码一直等待test('fetch success', done =&gt; &#123; fetch(data =&gt; &#123; expect(data.success).toBe(true) done() &#125;)&#125;)// 函数返回 promise 的写法，注意要加上 return// 当然对于返回 promise 的函数我们也可以直接使用 awaittest('fetch success', () =&gt; &#123; return fetch().then(data =&gt; &#123; expect(data.success).toBe(true) &#125;)&#125;) 实践单元测试case部署在tests/unit文件夹中，使用Jest编写。可以测试引入的公共方法，也可以测试一个单文件组件。建议按照代码组织结构来编写对应的单元测试case。 使用npm run unit来运行单元测试，测试结果会在命令行中显示。在构建测试环境的时候会自动运行单元测试，如果单元测试存在未通过的case，则构建会失败并终止。构建beta环境和生产环境暂时不会运行单元测试。 一个简单的关于为数字加入千位分隔符的方法的单元测试： 123456789describe('Utils suits', function () &#123; it('should add commas for numbers', function () &#123; let fn = Utils.addNumberCommas expect(fn(123)).toBe('123') expect(fn(12345)).toBe('12,345') expect(fn(1234567.89)).toBe('1,234,567.89') expect(fn(-1234567.89)).toBe('-1,234,567.89') &#125;)&#125;) 输出示例： 参考链接： Jest Vue单元测试 Vue_Test_Utils","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://unknownfor.github.io/tags/学习/"},{"name":"前端","slug":"前端","permalink":"http://unknownfor.github.io/tags/前端/"},{"name":"单元测试","slug":"单元测试","permalink":"http://unknownfor.github.io/tags/单元测试/"}]},{"title":"请求封装","slug":"请求与封装","date":"2018-03-29T13:32:01.000Z","updated":"2019-12-11T09:38:41.530Z","comments":true,"path":"2018/03/29/请求与封装/","link":"","permalink":"http://unknownfor.github.io/2018/03/29/请求与封装/","excerpt":"","text":"目前后台是微服务架构，所以不同的业务模块会请求到不同的地址，而不同的环境（测试/beta/生产）会携带不同的请求头进行区分，同时每个请求都有固定的参数携带，所以需要对请求进行统一的封装和管理。在这里记录一下封装请求的代码。 目前请求统一封装至 services 文件夹，按照后台模块名进行区分。每个请求都会封装成一个Promise，使用async/await进行异步请求管理。注意同时发起的多个请求使用Promise.all封装为一个新的Promise进行管理，防止串行请求影响性能。 12345let resp = await OpService.getProjects()console.log(resp)let requests = [UcService.getCurrentDeptLoginInfo(), UcService.getDepts()]let [currentDeptResp, deptsResp] = await Promise.all(requests) 1 utils/request.js 封装请求 1234567891011121314151617181920212223//module区分模块，模块名称封装在 【src/config/module.js】里//path 是请求的文件路径//data 是传入数据//noAccessToken 大部分时间都是false ，极端情况 比如登陆、投诉之类的不需要 get(module, path, data, noAccessToken = false) &#123; let p = new Promise(async function (resolve, reject) &#123; try &#123; let config = await BaseService.getConfig() let client = await BaseService.getClient(module) let services = config.services[module] let resp = await client.get(makeUrl(services.host, path, data, noAccessToken), &#123; headers: &#123; accept: 'application/json', &#125; &#125;) resolve(resp) &#125; catch (e) &#123; await handleError(e) reject(e) &#125; &#125;) return p &#125;, 2 eg: src\\services.js 封装请求 123456789101112131415161718/** * 登录后获取当前基础信息接口 */ //R是在build/webpack.base.conf.js里声明过的封装方法 //里面包含了基础的请求信息 function getCurrentDeptLoginInfo() &#123; let p = new Promise(async function (res, rej) &#123; try &#123; let resp = await R.get(Config.module.UC, '/user/get_current_dept_login_info') res(resp) &#125; catch (e) &#123; rej(e) &#125; &#125;) return p&#125; 3 应用请求 src\\app.js 调用封装的方法 123456789101112131415161718async handleDeptCommand(id) &#123; Loading.show() try &#123; let resp = await UserService.switchDept(id) if (resp.errcode == 0) &#123; let resp2 = await UserService.getCurrentDeptLoginInfo() BaseService.setBasicData(resp2.info) this._renderBasicData(resp2.info) this.$router.push('/') &#125; else &#123; console.error(new Error('errcode: ' + resp.errcode)) &#125; &#125; catch (e) &#123; console.error(e) &#125; finally &#123; Loading.hide() &#125; &#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://unknownfor.github.io/tags/前端/"},{"name":"VUE","slug":"VUE","permalink":"http://unknownfor.github.io/tags/VUE/"}]},{"title":"前端页面内权限控制规范","slug":"前端页面内权限控制规范","date":"2018-03-13T11:46:04.000Z","updated":"2019-12-11T09:04:00.317Z","comments":true,"path":"2018/03/13/前端页面内权限控制规范/","link":"","permalink":"http://unknownfor.github.io/2018/03/13/前端页面内权限控制规范/","excerpt":"","text":"201809更新v-auth控制弹窗内元素渲染会出现首次渲染成功后，第二次打开弹窗为false的情况，导致权限判断失败，页面样式错位，所以无法在弹窗内使用该方法。 解决方法：因为只需要页面初次加载时判断用户有无功能权限，通过接口查询一次后赋值给data的xx属性，通过属性的值来判断。 12345678910111213async created() &#123; // do someting // 查询有无删除调账记录权限 try &#123; let valid = await this.fCheckAuth('household.HOUSEHOLD_DELSUBJECT') if (valid) &#123; this.show_del = true &#125; &#125; catch (e) &#123; console.log(e) &#125;&#125;, 前端页面内权限控制规范目前的权限系统支持到动作点的细粒度控制，前端支持前置判断权限从而控制节点的展示与隐藏，执行相关逻辑等。前端通过 mixin 混入权限控制模块进行判断和处理。 自定义组件需要单独import &#39;@/mixin/auth&#39;，如果是已经引入了@/mixin的页面组件则不需要额外引入该模块。 该模块提供一个自定义指令v-auth和一个公共方法fCheckAuth，前者用来根据权限控制一个节点的展示或隐藏，后者通过该方法查询当前角色是否有某权限。 动作点管理动作点统一添加到@/config/auth。动作点通过模块管理，值为后台刷新的动作点名。 123456export default &#123; // 账单 bill: &#123; CONFIRM_OFFLINE_PAYMENT: 'accounting_billcenter_confirmofflinepayment' // 确认财务收款 &#125;&#125; v-authv-auth接收多种格式的参数。 传入字符串可以传入一个形如&#39;bill.CONFIRM_OFFLINE_PAYMENT&#39;的字符串，指令会到配置中寻找对应的路径查询当前动作点是否有权限，如果没有权限，则移除这个 DOM。 注意：传入的是字符串&#39;bill.CONFIRM_OFFLINE_PAYMENT&#39;，而不是bill.CONFIRM_OFFLINE_PAYMENT，后者会被框架当做组件的data值去获取。 传入对象可以传入的是一个对象： 参数名 类型 解释 auth String 逻辑处理同字符串参数 hide Boolean 如果为true，则将其display属性置为none（而不是从 dom 中移除这个节点） reverse Boolean 如果为true，则展示逻辑与正常相反，即无权限时展示该节点，有权限时移除这个节点 传入布尔值如果传入的是一个布尔值且该布尔值为false，则移除这个 DOM。作用同v-if。 fCheckAuth()方法使用this.fCheckAuth(auth)方法判断当前是否有auth权限，auth参数同v-auth自定义指令接收的字符串参数。 注意，这是一个异步方法。使用 1234let valid = await this.fCheckAuth('bill.CONFIRM_OFFLINE_PAYMENT')if (valid) &#123; // do something&#125; 或者 12345this.fCheckAuth('bill.CONFIRM_OFFLINE_PAYMENT').then(valid =&gt; &#123; if (valid) &#123; // do something &#125;&#125;) 判断是否具有相关权限。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://unknownfor.github.io/tags/前端/"},{"name":"开发文档","slug":"开发文档","permalink":"http://unknownfor.github.io/tags/开发文档/"}]},{"title":"手动实现all、bind、apply","slug":"手动实现all、bind、apply","date":"2017-09-23T10:32:59.000Z","updated":"2019-12-12T08:47:08.540Z","comments":true,"path":"2017/09/23/手动实现all、bind、apply/","link":"","permalink":"http://unknownfor.github.io/2017/09/23/手动实现all、bind、apply/","excerpt":"","text":"call原生call 123456789function test(arg1, arg2) &#123; console.log(arg1, arg2) console.log(this.a, this.b)&#125;run.call(&#123; a: 'a', b: 'b'&#125;, 1, 2) 在实现的过程有个关键： 如果一个函数作为一个对象的属性，那么通过对象的.运算符调用此函数，this 就是此对象 1234567891011let obj = &#123; a: 'a', b: 'b', test: function (arg1, arg2) &#123; console.log(arg1, arg2) // this.a 就是 a; this.b 就是 b console.log(this.a, this.b) &#125;&#125;obj.test(1, 2) 手动模拟call123456789101112131415161718192021222324252627282930Function.prototype.call2 = function(context) &#123; if(typeof this !== 'function') &#123; throw new TypeError('Error') &#125; // 默认上下文是window context = context || window // 保存默认的fn const &#123; fn &#125; = context // 前面讲的关键，将函数本身作为对象context的属性调用，自动绑定this context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) // 恢复默认的fn context.fn = fn return result&#125;// 以下是测试代码function test(arg1, arg2) &#123; console.log(arg1, arg2) console.log(this.a, this.b)&#125;test.call2(&#123; a: 'a', b: 'b'&#125;, 1, 2) bindbind有两个特点： 本身返回一个全新的函数，所以需要考虑new的清空 可以保留参数，内部实现了参数的拼接 123456789101112131415161718192021222324252627282930313233343536Function.prototype.bind2 = function(context) &#123; if(typeof this !== 'function') &#123; throw new TypeError('Error') &#125; const that = this // 保留之前的参数，为了下面的参数拼接 const args = [...arguments].slice(1) return function F() &#123; // 如果被new创建实例，不会被改变上下文！ if(this instanceof F) &#123; return new that(...args, ...arguments) &#125; // args.concat(...arguments): 拼接之前和现在的参数 // 注意：arguments是个类Array的Object, 用解构运算符..., 直接拿值拼接 return that.apply(context, args.concat(...arguments)) &#125;&#125;/** * 以下是测试代码 */function test(arg1, arg2) &#123; console.log(arg1, arg2) console.log(this.a, this.b)&#125;const test2 = test.bind2(&#123; a: 'a', b: 'b'&#125;, 1) // 参数 1test2(2) // 参数 2 applyapply和call实现类似，只是传入的参数形式是数组形式，而不是逗号分隔的参数序列。 因此，借助es6提供的…运算符，就可以很方便的实现数组和参数序列的转化。 12345678910111213141516171819202122232425262728293031323334Function.prototype.apply2 = function(context) &#123; if(typeof this !== 'function') &#123; throw new TypeError('Error') &#125; context = context || window const &#123; fn &#125; = context context.fn = this let result if(Array.isArray(arguments[1])) &#123; // 通过...运算符将数组转换为用逗号分隔的参数序列 result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; context.fn = fn return result&#125;/** * 以下是测试代码 */function test(arg1, arg2) &#123; console.log(arg1, arg2) console.log(this.a, this.b)&#125;test.apply2(&#123; a: 'a', b: 'b'&#125;, [1, 2])","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://unknownfor.github.io/tags/前端/"},{"name":"面试","slug":"面试","permalink":"http://unknownfor.github.io/tags/面试/"}]},{"title":"记录hexo替换主题","slug":"记录hexo替换主题","date":"2017-09-09T07:57:42.000Z","updated":"2019-12-11T09:06:52.962Z","comments":true,"path":"2017/09/09/记录hexo替换主题/","link":"","permalink":"http://unknownfor.github.io/2017/09/09/记录hexo替换主题/","excerpt":"","text":"博客也是上线了一年了，结果拖拖拉拉一直没什么东西写，今天闲来无事想着更换看腻了的博客主题。在 hexo主题官网 找到了一款极简的主题 polarbear ,安装替换现有主题都是常规流程。参考制作人的readme步骤。 12$ npm install hexo-renderer-scss --save$ git clone https://github.com/frostfan/hexo-theme-polarbear themes/polarbear 修改配置 _config.yml123456789101112# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: polarbear# 在归档页面显示所有文章 （Show all articles on archive page.）# 需要安装(Need to install) hexo-generator-archive 插件支持archive_generator: per_page: 0 yearly: false monthly: false daily: false 结果 archive 和 about 遇到了问题。右上角的归档页和关于我找不到路径。 更换自己喜欢的网页图标网上搜索自己喜欢的图片，尺寸小，注意格式要是.ico,替换本地themes文件夹下的favicon.icon文件即可。 解决about找不到排查了一下问题，可能是文件找不到。终于找到了相关教程，new了文件 12hexo new page \"about\"hexo new page \"archives\" 执行命令后在本地站点的source目录下生成一个about文件夹，修改about文件夹下的index.md。相应的archives也要修改type 12345---title: aboutdate: 2016-03-23 14:24:06type: about--- 12345---title: archivesdate: 2016-03-23 14:24:06type: archive--- 重启服务就发现about可以正常跳转一个空页了。 解决archive找不到百思不得其解为什么hexo没有自动生成archive，明明是安装了插件就可以支持的。重新执行了一下安装命令。1npm install --save hexo-generator-archive 在node_modules下找到了相应的hexo-generator-archive，证明插件安装成功。但是还是没有自动生成。 终于排查到了问题，_config.yml 网站配置文件里的文件目录写错了 1234# 错误archive_dir: archive# 正确archive_dir: archives 终于成功了！ 以下是9月10日更新：侧边栏没有展示自定义的widget 修改本地站点的 _config.yml 的相关配置语句并没有生效，经过排查发现是主题的 _config.yml 的相关配置是false，看来主题的配置权重更高。修改为false之后就发现了自定义的 widget_custom 出现了。 参考文章 官方说明 Hexo安装配置详解","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://unknownfor.github.io/tags/hexo/"}]},{"title":"Element日期选择组件时间选择限定","slug":"Element日期选择组件时间选择限定","date":"2017-07-18T07:50:38.000Z","updated":"2019-12-12T09:19:34.420Z","comments":true,"path":"2017/07/18/Element日期选择组件时间选择限定/","link":"","permalink":"http://unknownfor.github.io/2017/07/18/Element日期选择组件时间选择限定/","excerpt":"","text":"2018 年 12 月更新：要求禁用时间不能小于启用时间。问题： 启用时间是动态更新的，不同数据启用时间不同，导致禁用时间范围也不一样。在data初始赋值后不会再更新pickerOptions解决方法：watch 启用时间，每次更新启用时间都动态更新一次pickerOptions Template12345678910111213141516171819202122232425262728&lt;el-form-item label=\"启用月份\" prop=\"start_year_month\"&gt; &lt;el-date-picker v-model=\"form.start_year_month\" type=\"month\" format=\"yyyy 年 MM\" value-format=\"yyyyMM\" style=\"width: 100%\" placeholder=\"请选择启用月份\" :clearable=\"false\" :editable=\"false\" &gt;&lt;/el-date-picker&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"禁用月份\" prop=\"stop_year_month\" &gt; &lt;el-date-picker :picker-options=\"pickerOptions\" v-model=\"form.stop_year_month\" :clearable=\"false\" :editable=\"false\" type=\"month\" style=\"width: 100%\" format=\"yyyy 年 MM\" value-format=\"yyyyMM\" placeholder=\"请选择禁用月份\" &gt;&lt;/el-date-picker&gt; &lt;/el-form-item&gt; Script123456789101112131415161718192021data: &#123; pickerOptions: &#123;&#125;, form: &#123; start_year_month: '', stop_year_month: '' &#125;&#125;watch: &#123; // time.getTime是把选中的时间转化成自1970年1月1日 00:00:00 UTC到当前时间的毫秒数 // 当前启用日期为 ‘201912’ ，只包含日期，导致return范围不对，需要转换为‘2019-12’ ['form.start_year_month'](val) &#123; this.pickerOptions = Object.assign(&#123;&#125;, this.pickerOptions, &#123; // disabledDate 为true表示不可选,false表示可选 disabledDate: (time) =&gt; &#123; let str = val.slice(0, 4) + '-' + val.slice(4, 7) str = new Date(str).getTime() return time.getTime() &lt; str // 可选时间范围大于等于启用日期 &#125; &#125;)&#125; 实现效果 2018 年 7 月更新：产品觉得饿了么的时间范围选择器不方便，要求使用两个单独的时间选择器做时间范围筛选。 Template1234567891011121314151617&lt;el-date-picker v-model=\"startDate\" type=\"date\" placeholder=\"选择开始日期\" :picker-options=\"pickerOptionsStart\" @change=\"changeEnd\"&gt;&lt;/el-date-picker&gt;&lt;el-date-picker v-model=\"endDate\" type=\"date\" placeholder=\"选择结束日期\" :picker-options=\"pickerOptionsEnd\" @change=\"changeStart\"&gt;&lt;/el-date-picker&gt; Script123456789101112131415161718192021222324data() &#123; return &#123; pickerOptionsStart: &#123;&#125;, pickerOptionsEnd:&#123;&#125;, startDate: '', endDate: '', &#125;;methods:&#123; changeStart ()&#123; this.pickerOptionsStart = Object.assign(&#123;&#125;,this.pickerOptionsStart,&#123; disabledDate: (time) =&gt; &#123; return time.getTime() &gt; this.endDate &#125; &#125;) &#125;, changeEnd ()&#123; this.pickerOptionsEnd = Object.assign(&#123;&#125;,this.pickerOptionsEnd,&#123; disabledDate: (time) =&gt; &#123; return time.getTime() &lt; this.startDate &#125; &#125;) &#125; &#125; 2018 年 4 月更新：做企业合同办理入住遇到新的需求，特此记录一下。 12345678910111213141516171819202122import moment from 'moment'export default function () &#123; let that = this return &#123; /** * * 不允许选择未来日期 * 允许选择合同开始前的30天,（即往前推29天） * 如果合同租期已结束，可选最大时间为租期结束时间 */ pickerOptions: &#123; disabledDate(time) &#123; let curDate = (new Date()).getTime() let start = new Date(that.form.rent_start).getTime() let end = new Date(that.form.rent_end).getTime() let three = 30 * 24 * 3600 * 1000 if (moment().isAfter(that.form.rent_end, 'day')) &#123; return time.getTime() &lt; start - three || time.getTime() &gt; end &#125; return time.getTime() &lt; start - three || time.getTime() &gt; curDate &#125; &#125; &#125; 应用场景：双栏日期选择。选定开始日期后，结束日期只能限定在开始日期后三个月内的任意一天。 缺点:内部循环遍历所有日期，性能较差 代码： datepick.html 123&lt;div id=\"datepick\"&gt; &lt;datepick&gt;&lt;/datepick&gt;&lt;/div&gt; datepick.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=\"block\"&gt; &lt;el-date-picker v-model=\"value1\" type=\"date\" placeholder=\"开始日期\" :picker-options=\"pickerOptions0\"&gt; &lt;/el-date-picker&gt; &lt;el-date-picker v-model=\"value2\" type=\"date\" placeholder=\"结束日期\" :picker-options=\"pickerOptions1\"&gt; &lt;/el-date-picker&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; value1:'', value2:'', pickerOptions1: &#123; //disabledDate是日期组件的一个方法 disabledDate: (time) =&gt; &#123; //这里就涉及到日期的指定了 setMonth()函数可以设置月份 let currentTime = this.value1; let threeMonths = currentTime.setMonth(currentTime.getMonth()+3); //一开始我没加下面减三个月的那个语句，他的值会一直累加 currentTime.setMonth(currentTime.getMonth()-3) return time.getTime() &lt; this.value1 || time.getTime() &gt; threeMonths ; &#125; &#125; &#125; &#125; &#125; &lt;/script&gt; datepick.js 123456789101112import Vue from 'vue';import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';import datepick from '../components/datepick.vue';Vue.use(ElementUI);new Vue(&#123; el: \"#datepick\", template:'&lt;datepick/&gt;', components: &#123;datepick&#125;&#125;)","categories":[],"tags":[{"name":"Element","slug":"Element","permalink":"http://unknownfor.github.io/tags/Element/"}]},{"title":"元素水平垂直居中","slug":"元素水平垂直居中","date":"2017-07-09T07:27:42.000Z","updated":"2019-12-11T08:33:34.549Z","comments":true,"path":"2017/07/09/元素水平垂直居中/","link":"","permalink":"http://unknownfor.github.io/2017/07/09/元素水平垂直居中/","excerpt":"","text":"方法一：position加margin 方法二： diaplay:table-cell 方法三：position加 transform 方法四：flex;align-items: center;justify-content: center 方法五：display:flex;margin:auto 方法六：transfer -50% 方法七：兼容低版本浏览器，不固定宽高 示例图 1.position加margin父元素和子元素高宽都固定，使用绝对定位的方法居中1234567891011121314151617181920212223/**html**/&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;/**css**/.parent &#123; width: 200px; height: 200px; background: yellow; position: relative;&#125;.child &#123; width: 100px; height: 100px; background: green; margin: auto; position: absolute; left: 0; right: 0; top: 0; bottom: 0;&#125; 2.display:tabel-cell父元素必须为tabel-cell，子元素必须为display：inline-block 123456789101112131415161718192021&lt;!-- html --&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;/*css*/.parent &#123; width: 200px; height: 200px; background: yellow; display: table-cell; vertical-align: middle; text-align: center;&#125;.child&#123; display: inline-block; vertical-align: middle; width: 100px; height: 100px; background: green;&#125; 3.position加 transform不需要考虑父元素的高宽，可以做自适应，但是子元素的高宽必须限定 12345678910111213141516171819202122&lt;!-- html --&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt; /* css */.parentss &#123; position: relative; background: yellow; width: 200px; height: 200px;&#125;.child &#123; position: absolute; background: green; top:50%; left:50%; -webkit-transform:translate(-50%,-50%); transform:translate(-50%,-50%); width: 100px; height: 100px;&#125; 4.flex;alige-item:center;justify-content: center子元素和父元素都无需限定高宽，移动端兼容性良好 1234567891011121314151617181920&lt;!-- html --&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;/* css */.parent &#123; background: yellow; width: 200px; height: 200px; display: flex; align-items: center; justify-content: center;&#125;.child &#123; background: green; width: 100px; height: 100px;&#125; 5.display:flex;margin:auto兼容性没测试过，移动端适用 12345678910111213141516171819&lt;!-- html --&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;/* css */.parent &#123; background: yellow; width: 200px; height: 200px; display: flex; &#125;.child &#123; background: green; width: 100px; height: 100px; margin: auto;&#125; 6.tranfer -50%百分比来设置宽高 123456789101112//vertical center.vertical-center&#123; position absolute top 50% transform translate(0,-50%)&#125;.vertical-horizontal&#123; position absolute left 50% top 50% transform translate(-50%,-50%)&#125; 12345678910111213141516171819202122&lt;!-- html --&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;/* css */.parent &#123; &#125;.child &#123; position: absolute; top: 50%; left: 50%; width:50%; height:30%; padding:20px; text-align:center; background:#393; color:#fff; transform: translate(-50%, -50%);&#125; 7.高宽不定1234567891011121314151617181920212223242526272829303132&lt;!-- html --&gt;&lt;div class=\"table\"&gt; &lt;div class=\"tableCell\"&gt; &lt;div class=\"content\"&gt;不固定宽高，自适应&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; /*css*/.table &#123; height: 200px;/*高度值不能少*/ width: 200px;/*宽度值不能少*/ display: table; position: relative; float:left; background: yellow;&#125; .tableCell &#123; display: table-cell; vertical-align: middle; text-align: center; *position: absolute; padding: 10px; *top: 50%; *left: 50%;&#125;.content &#123; *position:relative; *top: -50%; *left: -50%; background: green;&#125;","categories":[],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://unknownfor.github.io/tags/移动开发/"}]},{"title":"Vue中样式覆盖-style的scoped属性","slug":"Vue中样式覆盖-style的scoped属性","date":"2017-07-06T07:01:37.000Z","updated":"2019-12-11T08:05:07.866Z","comments":true,"path":"2017/07/06/Vue中样式覆盖-style的scoped属性/","link":"","permalink":"http://unknownfor.github.io/2017/07/06/Vue中样式覆盖-style的scoped属性/","excerpt":"","text":"背景 &emsp;项目使用Vue和ElementUi，想要覆盖ElementUi默认的输入框样式，新增自定义CSS样式，根据el-input编译后生成的class修改，但是样式并不生效。 后来发现修改1&lt;style type=\"text/css\" scoped&gt;&lt;/style&gt; 标签里的scoped删除就生效了。 原因 &emsp;scope可以做到样式私有化，及当前样式只作用于当前模块，不会影响全局。 &emsp;通过查看DOM结构发现：vue通过在DOM结构以及css样式上加唯一不重复的标记，以保证唯一，达到样式私有化模块化的目的。具体的渲染结果是怎样的，通过一个例子来说明。 举个栗子 &emsp;一个公共组件button，为了样式模块化，给其加上scoped属性 1234567891011121314151617//button.vue&lt;template&gt; &lt;div class=\"button-warp\"&gt; &lt;button class=\"button\"&gt;text&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;...&lt;style scoped&gt; .button-warp&#123; display:inline-block; &#125; .button&#123; padding: 5px 10px; font-size: 12px; border-radus: 2px; &#125;&lt;/style&gt; &emsp;浏览器渲染的button组件，其html和css结构如下： 123&lt;div data-v-2311c06a class=\"button-warp\"&gt; &lt;button data-v-2311c06a class=\"button\"&gt;text&lt;/button&gt;&lt;/div&gt; 12345678.button-warp[data-v-2311c06a]&#123; display:inline-block;&#125;.button[data-v-2311c06a]&#123; padding: 5px 10px; font-size: 12px; border-radus: 2px;&#125; &emsp;从上面的案例可以看出，添加了scoped属性的组件，为了达到组件样式模块化，做了两个处理： 给 HTML的 DOM节点加一个不重复data属性(形如：data-v-2311c06a)来表示他的唯一性 在每句 css选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器（如[data-v-2311c06a]）来私有化样式 &emsp;但这势必影响到css的优先级，scoped虽然达到了组件样式模块化，但是会导致每个样式的权重加重。理论上我们要修改这个样式的话，需要更高的权重去修改，增加了复杂度。 外部引用&emsp;栗子说明了单个组件渲染，当遇到组件相互调用，如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的data属性。 解决方案&emsp;vue-loader的深度作用选择器。 &emsp;在vue.js中，&lt;style scoped&gt;的作用域在本html页面，&lt;style&gt;样式的作用域则是全局（即所有html页面），由于我把其中一个html页面的&lt;style scoped&gt;scoped去掉，这个页面的样式就变成了全局样式，当其它页面和这些全局样式重class名时，样式会被覆盖（vue默认全局样式覆盖局部样式），这样就导致当前页面定义样式影响到全局样式。 &emsp;如何在&lt;style scoped&gt;局部样式中覆盖全局样式：父组件cssName+ /deep/+第三方库需要更改的cssName 123比如修改class为el-input__inner的元素，它的父class为input_percent，则在style中写入input_percent /deep/ .el-input__inner &#123;&#125;即可","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://unknownfor.github.io/tags/Vue/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2017-03-08T16:04:37.000Z","updated":"2019-12-11T09:02:34.260Z","comments":true,"path":"2017/03/09/markdown语法/","link":"","permalink":"http://unknownfor.github.io/2017/03/09/markdown语法/","excerpt":"","text":"强调 分割线 引用 嵌套列表 段落缩进（空格） 字体、字号、颜色 标签 当前目录使用的索引超链的方式 强调1234567**强调文字**__强调文字__*强调文字强调文字*_强调文字_ 强调文字强调文字 强调文字强调文字 强调文字 分割线12--- 引用12&gt;引用 &gt;&gt;引用中的引用 引用 引用中的引用 嵌套列表123456- 嵌套列表1 + 嵌套列表2 + 嵌套列表3 - 嵌套列表4 * 嵌套列表5- 嵌套列表6 嵌套列表1 嵌套列表2 嵌套列表3 嵌套列表4 嵌套列表5 嵌套列表6 段落缩进1234半方大的空白&amp;ensp;或&amp;#8194;看，飞碟全方大的空白&amp;emsp;或&amp;#8195;看，飞碟不断行的空白格&amp;nbsp;或&amp;#160;看，飞碟&amp;emsp;&amp;emsp;段落从此开始。 半方大的空白&ensp;或&#8194;看，飞碟 全方大的空白&emsp;或&#8195;看，飞碟 不断行的空白格&nbsp;或&#160;看，飞碟 &emsp;&emsp;段落从此开始。 字体、字号、颜色123456&lt;font face=\"黑体\"&gt;我是黑体字&lt;/font&gt;&lt;font face=\"微软雅黑\"&gt;我是微软雅黑&lt;/font&gt;&lt;font face=\"STCAIYUN\"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=\"黑体\"&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt; 我是黑体字 我是微软雅黑 我是华文彩云 黑体 null gray 标签1行内标签` 这是一个有颜色的标签","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://unknownfor.github.io/tags/学习/"}]}],"categories":[],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://unknownfor.github.io/tags/移动开发/"},{"name":"生活","slug":"生活","permalink":"http://unknownfor.github.io/tags/生活/"},{"name":"移动端","slug":"移动端","permalink":"http://unknownfor.github.io/tags/移动端/"},{"name":"Element","slug":"Element","permalink":"http://unknownfor.github.io/tags/Element/"},{"name":"前端","slug":"前端","permalink":"http://unknownfor.github.io/tags/前端/"},{"name":"vue","slug":"vue","permalink":"http://unknownfor.github.io/tags/vue/"},{"name":"学习","slug":"学习","permalink":"http://unknownfor.github.io/tags/学习/"},{"name":"单元测试","slug":"单元测试","permalink":"http://unknownfor.github.io/tags/单元测试/"},{"name":"VUE","slug":"VUE","permalink":"http://unknownfor.github.io/tags/VUE/"},{"name":"开发文档","slug":"开发文档","permalink":"http://unknownfor.github.io/tags/开发文档/"},{"name":"面试","slug":"面试","permalink":"http://unknownfor.github.io/tags/面试/"},{"name":"hexo","slug":"hexo","permalink":"http://unknownfor.github.io/tags/hexo/"},{"name":"Vue","slug":"Vue","permalink":"http://unknownfor.github.io/tags/Vue/"}]}